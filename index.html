<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>VIEHOUSE — 3D Property Viewer</title>

    <!--
      What’s new (high level):
      • CSS: consolidated variables, better contrast, accessible focus, modern buttons, segmented controls, mobile polish.
      • Controls: fixed A/D + arrow key mapping, exits pointer-lock on UI click, reduced duplicated logic.
      • Measurement: surface picking with Raycaster (Meshes/Points) + ground-plane fallback, live preview “rubber band”,
        units (m/ft), two-point or polyline mode, total + per‑segment lengths, export/copy,
        nicer markers + labels rendered as sprites, touch support.
    -->

    <style>
        /* =============================
         DESIGN TOKENS
      ============================== */
        :root {
            --bg: #0f1115;
            --panel: rgba(17, 18, 22, 0.86);
            --panel-border: rgba(255, 255, 255, 0.12);
            --text: #f5f7fb;
            --muted: #c7c9d3;
            --muted-2: #9aa1ac;
            --accent: #4fa1ff;
            --accent-2: #6de1ff;
            --danger: #ff5a6a;
            --ok: #27d6a0;

            --ring: 0 0 0 3px rgba(79, 161, 255, 0.35);
            --shadow-1: 0 8px 30px rgba(0, 0, 0, 0.4);
            --shadow-2: 0 3px 12px rgba(0, 0, 0, 0.3);

            --radius-lg: 16px;
            --radius-md: 12px;
            --radius-sm: 8px;

            --space-1: 4px;
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
            --space-5: 20px;
            --space-6: 24px;
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(1200px 800px at 85% 90%,
                    #131720 20%,
                    var(--bg) 60%);
            color: var(--text);
            font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
                Arial, "Apple Color Emoji", "Segoe UI Emoji";
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;

            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* =============================
         LOADING
      ============================== */
        #loading-screen {
            position: fixed;
            inset: 0;
            display: grid;
            place-content: center;
            gap: var(--space-4);
            background: linear-gradient(180deg,
                    #0d0f14 0%,
                    #0f1115 60%,
                    #0f1115 100%);
            z-index: 1000;
            transition: opacity 0.4s ease, visibility 0.4s ease;
        }

        #loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .loading-spinner {
            width: 56px;
            height: 56px;
            border: 3px solid rgba(255, 255, 255, 0.18);
            border-top: 3px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-inline: auto;
        }

        .loading-bar {
            width: min(320px, 80vw);
            height: 6px;
            background: rgba(255, 255, 255, 0.12);
            border-radius: 3px;
            overflow: hidden;
            box-shadow: var(--shadow-2) inset;
        }

        .loading-bar>.progress {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            transition: width 0.25s ease;
        }

        .loading-text {
            font-weight: 600;
            text-align: center;
        }

        .loading-subtext {
            color: var(--muted-2);
            text-align: center;
            max-width: 36ch;
            margin-inline: auto;
            font-size: 12px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* =============================
         PANELS + TOGGLES
      ============================== */
        .floating-panel {
            position: absolute;
            background: var(--panel);
            border: 1px solid var(--panel-border);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-1);
            backdrop-filter: blur(10px);
            padding: var(--space-5);
            font-size: 13px;
            opacity: 0;
            transform: translateY(-8px);
            transition: opacity 0.25s ease, transform 0.25s ease;
            pointer-events: none;
        }

        .floating-panel.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        #controls-panel {
            top: 20px;
            left: 20px;
            max-width: 300px;
        }

        #measure-panel {
            top: 20px;
            right: 20px;
            min-width: 260px;
            max-width: 320px;
        }

        .circle-toggle {
            position: absolute;
            top: 20px;
            width: 42px;
            height: 42px;
            border-radius: 50%;
            border: 0;
            background: #ffffff;
            color: #111;
            display: grid;
            place-content: center;
            font-size: 18px;
            font-weight: 700;
            box-shadow: var(--shadow-2);
            cursor: pointer;
            transition: transform 0.2s ease, background 0.2s ease;
            z-index: 101;
        }

        .circle-toggle:hover {
            transform: scale(1.08);
        }

        #controls-toggle {
            left: 20px;
        }

        #measure-toggle {
            right: 20px;
        }

        .section {
            padding-block: var(--space-3);
            border-bottom: 1px dashed var(--panel-border);
        }

        .section:last-child {
            border-bottom: 0;
        }

        .section-title {
            font-weight: 700;
            letter-spacing: 0.02em;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: var(--space-3);
        }

        .row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--space-3);
            margin-bottom: var(--space-2);
        }

        .kbd {
            background: #fff;
            color: #111;
            padding: 4px 8px;
            border-radius: 6px;
            font-weight: 700;
            font-size: 11px;
            box-shadow: var(--shadow-2);
            min-width: 70px;
            text-align: center;
        }

        .label {
            color: var(--muted);
            font-size: 12px;
            flex: 1;
            text-align: right;
        }

        .control-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: var(--space-3);
            margin-top: var(--space-2);
        }

        .card {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-md);
            padding: var(--space-3);
            text-align: center;
        }

        .card .icon {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            background: #fff;
            display: grid;
            place-content: center;
            color: #111;
            font-weight: 700;
            margin-inline: auto;
            margin-bottom: var(--space-2);
        }

        .card .tag {
            font-size: 10px;
            color: var(--muted-2);
        }

        /* Buttons */
        .btn {
            appearance: none;
            border: 1px solid var(--panel-border);
            background: linear-gradient(180deg,
                    rgba(255, 255, 255, 0.12),
                    rgba(255, 255, 255, 0.06));
            color: var(--text);
            border-radius: 10px;
            padding: 8px 12px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.15s ease, border-color 0.2s ease,
                background 0.2s ease;
        }

        .btn:hover {
            transform: translateY(-1px);
            border-color: rgba(255, 255, 255, 0.25);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn[disabled] {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(180deg, var(--accent), #3388ff);
            border-color: transparent;
            color: #0d1020;
        }

        .btn-danger {
            background: linear-gradient(180deg, #ff6b7a, #ff4b5d);
            border-color: transparent;
            color: #1a0c0f;
        }

        .btn-ghost {
            background: transparent;
        }

        .segmented {
            display: flex;
            gap: 6px;
        }

        .segmented .seg {
            flex: 1;
            border-radius: 8px;
            padding: 6px 10px;
            font-weight: 700;
            border: 1px solid var(--panel-border);
            background: rgba(255, 255, 255, 0.04);
            color: var(--muted);
            cursor: pointer;
        }

        .segmented .seg.on {
            color: var(--text);
            border-color: rgba(255, 255, 255, 0.24);
            background: rgba(255, 255, 255, 0.1);
        }

        .field {
            display: grid;
            grid-template-columns: 92px 1fr;
            align-items: center;
            gap: 10px;
            margin-bottom: var(--space-3);
        }

        .field>label {
            color: var(--muted);
            font-size: 12px;
        }

        /* Indicators */
        #move-indicator,
        #rotate-indicator {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 16px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.78);
            border: 1px solid var(--panel-border);
            box-shadow: var(--shadow-2);
            font-weight: 700;
            display: none;
            z-index: 101;
        }

        #move-indicator {
            bottom: 100px;
        }

        #rotate-indicator {
            top: 100px;
        }

        /* Logo */
        #vh-logo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 90;
            display: grid;
            justify-items: center;
            gap: 6px;
            pointer-events: none;
        }

        .logo-box {
            width: 80px;
            height: 80px;
            padding: 12px;
            border-radius: 20px;
            background: #fff;
            border: 2px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 8px 22px rgba(0, 0, 0, 0.45);
            overflow: hidden;
            display: grid;
            place-content: center;
        }

        .logo-box img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
        }

        .powered {
            font-size: 10px;
            color: var(--muted);
            text-align: center;
        }

        /* Mobile */
        @media (max-width: 768px) {
            .circle-toggle {
                width: 52px;
                height: 52px;
                font-size: 20px;
            }

            .floating-panel {
                padding: var(--space-6);
                font-size: 14px;
                max-width: min(92vw, 420px);
            }

            #vh-logo {
                bottom: 150px;
            }
        }

        .desktop-only {
            display: block;
        }

        @media (max-width: 768px) {
            .desktop-only {
                display: none;
            }
        }

        .mobile-only {
            display: none;
        }

        @media (max-width: 768px) {
            .mobile-only {
                display: block;
            }
        }

        /* Virtual joystick (mobile) */
        #joystick {
            position: fixed;
            bottom: 120px;
            left: 30px;
            width: 110px;
            height: 110px;
            z-index: 1000;
            touch-action: none;
            display: none;
        }

        #joy-base {
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.18);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            position: relative;
            backdrop-filter: blur(5px);
        }

        #joy-handle {
            position: absolute;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.95);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: transform 0.08s linear;
            box-shadow: var(--shadow-2);
        }

        @media (max-width: 768px) {
            #joystick {
                display: block;
            }
        }

        /* Focus visibility */
        :is(button, a, [tabindex]):focus-visible {
            outline: none;
            box-shadow: var(--ring);
        }

        /* Reduced motion */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.001s !important;
                transition-duration: 0.001s !important;
            }
        }
    </style>
</head>

<body>
    <!-- Loading Screen -->
    <div id="loading-screen" aria-live="polite">
        <div class="loading-spinner" aria-hidden="true"></div>
        <div class="loading-bar" aria-hidden="true">
            <div class="progress" id="progress"></div>
        </div>
        <div class="loading-text" id="loading-text">
            Initializing 3D Renderer…
        </div>
        <div class="loading-subtext" id="loading-subtext">
            Preparing your property visualization experience
        </div>
    </div>

    <!-- Toggles -->
    <button class="circle-toggle" id="controls-toggle" aria-controls="controls-panel" aria-pressed="false"
        title="Show/Hide Controls">
        ⚙️
    </button>
    <button class="circle-toggle" id="measure-toggle" aria-controls="measure-panel" aria-pressed="false"
        title="Show/Hide Measurement">
        📐
    </button>

    <!-- Controls Panel -->
    <aside id="controls-panel" class="floating-panel" aria-hidden="true">
        <div class="section">
            <div class="section-title">Navigation</div>
            <div class="row desktop-only">
                <div class="kbd">LEFT CLICK</div>
                <div class="label">360° Look</div>
            </div>
            <div class="row desktop-only">
                <div class="kbd">RIGHT CLICK</div>
                <div class="label">Pan</div>
            </div>
            <div class="row desktop-only">
                <div class="kbd">WHEEL</div>
                <div class="label">Zoom</div>
            </div>
            <div class="row desktop-only">
                <div class="kbd">MIDDLE</div>
                <div class="label">Quick Zoom</div>
            </div>

            <div class="mobile-only" style="margin-top: var(--space-3)">
                <div class="row">
                    <div class="kbd">ONE FINGER</div>
                    <div class="label">Look</div>
                </div>
                <div class="row">
                    <div class="kbd">TWO FINGERS</div>
                    <div class="label">Zoom &amp; Pan</div>
                </div>
                <div class="row">
                    <div class="kbd">JOYSTICK</div>
                    <div class="label">Move</div>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Movement</div>
            <div class="row">
                <div class="kbd">W / ↑</div>
                <div class="label">Forward</div>
            </div>
            <div class="row">
                <div class="kbd">S / ↓</div>
                <div class="label">Backward</div>
            </div>
            <div class="row">
                <div class="kbd">A / ←</div>
                <div class="label">Left</div>
            </div>
            <div class="row">
                <div class="kbd">D / →</div>
                <div class="label">Right</div>
            </div>
            <div class="row">
                <div class="kbd">Q</div>
                <div class="label">Up</div>
            </div>
            <div class="row">
                <div class="kbd">E</div>
                <div class="label">Down</div>
            </div>
            <div class="row desktop-only">
                <div class="kbd">SHIFT</div>
                <div class="label">Turbo</div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Quick Controls</div>
            <div class="control-grid">
                <div class="card">
                    <div class="icon">👁️</div>
                    <div class="tag">LOOK</div>
                </div>
                <div class="card">
                    <div class="icon">🔄</div>
                    <div class="tag">PAN</div>
                </div>
                <div class="card">
                    <div class="icon">🏃</div>
                    <div class="tag">MOVE</div>
                </div>
                <div class="card desktop-only">
                    <div class="icon">⚡</div>
                    <div class="tag">TURBO</div>
                </div>
            </div>
        </div>
    </aside>

    <!-- Measurement Panel -->
    <aside id="measure-panel" class="floating-panel" aria-hidden="true">
        <div class="section-title">📐 Measurement</div>

        <div class="field">
            <label>Pick Mode</label>
            <div class="segmented" role="group" aria-label="Pick mode">
                <button class="seg on" id="pick-surface" title="Snap to surfaces (Meshes/Points)">
                    Surface
                </button>
                <button class="seg" id="pick-ground" title="Project to ground (z=0)">
                    Ground
                </button>
            </div>
        </div>

        <div class="field">
            <label>Units</label>
            <div class="segmented" role="group" aria-label="Units">
                <button class="seg on" data-unit="m">m</button>
                <button class="seg" data-unit="ft">ft</button>
            </div>
        </div>

        <div class="field">
            <label>Mode</label>
            <div class="segmented" role="group" aria-label="Mode">
                <button class="seg on" data-mode="two">Two‑Point</button>
                <button class="seg" data-mode="path">Path</button>
            </div>
        </div>

        <div class="section" style="display: flex; gap: 8px; flex-wrap: wrap">
            <button class="btn btn-primary" id="measure-start">Start</button>
            <button class="btn" id="measure-finish" disabled>Finish</button>
            <button class="btn btn-danger" id="measure-clear" disabled>
                Clear
            </button>
            <button class="btn btn-ghost" id="measure-copy" disabled title="Copy result to clipboard">
                Copy
            </button>
        </div>

        <div class="section" style="border-bottom: 0">
            <div style="font-size: 12px; color: var(--muted-2); margin-bottom: 6px">
                Click or tap to place points. In path mode, place multiple points then
                “Finish”.
            </div>
            <div id="measure-output" style="font-size: 18px; font-weight: 800">
                0.00 m
            </div>
            <div id="measure-notes" style="font-size: 12px; color: var(--muted-2); margin-top: 4px">
                Ready.
            </div>
            <div id="measure-segments" style="
            font-size: 12px;
            color: var(--muted);
            margin-top: 8px;
            display: none;
          "></div>
        </div>
    </aside>

    <!-- Virtual Joystick (mobile) -->
    <div id="joystick">
        <div id="joy-base">
            <div id="joy-handle"></div>
        </div>
    </div>

    <!-- Logo -->
    <div id="vh-logo">
        <div class="logo-box">
            <img src="images/VIEHOUSE_logo.png" alt="VIEHOUSE Logo" />
        </div>
        <div class="powered">POWERED BY<br />VIEHOUSE</div>
    </div>

    <!-- Indicators -->
    <div id="move-indicator">Moving…</div>
    <div id="rotate-indicator">Rotating…</div>

    <!-- three.js + app -->
    <script type="importmap">
      {
        "imports": {
          "three": "./lib/three/three.module.js",
          "three/addons/": "./lib/three/jsm/"
        }
      }
    </script>

    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { LCCRender } from "./sdk/lcc-0.4.0.js";

        /* =====================================================
           DOM cache
        ====================================================== */
        const loadingScreen = document.getElementById("loading-screen");
        const progressBar = document.getElementById("progress");
        const loadingText = document.getElementById("loading-text");
        const loadingSubtext = document.getElementById("loading-subtext");

        const controlsToggle = document.getElementById("controls-toggle");
        const measureToggle = document.getElementById("measure-toggle");
        const controlsPanel = document.getElementById("controls-panel");
        const measurePanel = document.getElementById("measure-panel");

        const moveIndicator = document.getElementById("move-indicator");
        const rotateIndicator = document.getElementById("rotate-indicator");

        // Measurement UI
        const btnStart = document.getElementById("measure-start");
        const btnFinish = document.getElementById("measure-finish");
        const btnClear = document.getElementById("measure-clear");
        const btnCopy = document.getElementById("measure-copy");
        const output = document.getElementById("measure-output");
        const notes = document.getElementById("measure-notes");
        const segmentsList = document.getElementById("measure-segments");
        const pickSurfaceBtn = document.getElementById("pick-surface");
        const pickGroundBtn = document.getElementById("pick-ground");
        const unitButtons = [...measurePanel.querySelectorAll("[data-unit]")];
        const modeButtons = [...measurePanel.querySelectorAll("[data-mode]")];

        /* =====================================================
           Scene & Renderer
        ====================================================== */
        const scene = new THREE.Scene();
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        const DPR = () =>
            window.innerWidth < 768
                ? Math.min(1.5, window.devicePixelRatio)
                : window.devicePixelRatio;
        renderer.setPixelRatio(DPR());
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x0f1115);
        document.body.appendChild(renderer.domElement);

        // Camera (Z-up world)
        const camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.up.set(0, 0, 1);
        camera.position.set(9, 2, 2);

        // Manual rotation state
        const camRot = { yaw: 0, pitch: 0 };

        // Orbit controls for pan/zoom only
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableRotate = false;
        controls.enableZoom = true;
        controls.enablePan = true;
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.panSpeed = 1.5;
        controls.zoomSpeed = 1.2;
        controls.mouseButtons = {
            LEFT: null,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.PAN,
        };
        controls.update();

        // Ambient env (subtle, helps readability)
        scene.add(new THREE.AmbientLight(0xffffff, 0.25));

        /* =====================================================
           Loading LCC (Gaussian splats) with progress
        ====================================================== */
        function setProgress(pct, label) {
            progressBar.style.width = Math.max(0, Math.min(100, pct)) + "%";
            if (label) loadingText.textContent = label;
            if (pct < 30)
                loadingSubtext.textContent = "Initializing 3D environment…";
            else if (pct < 60) loadingSubtext.textContent = "Loading model data…";
            else if (pct < 90)
                loadingSubtext.textContent = "Processing surfaces and textures…";
            else loadingSubtext.textContent = "Finalizing rendering setup…";
        }
        function hideLoading() {
            loadingScreen.classList.add("hidden");
            setTimeout(() => (loadingScreen.style.display = "none"), 450);
        }

        setProgress(8, "Booting renderer…");
        let lccObj = null;
        const DATA_URL = "https://7cljve8li97skpij.public.blob.vercel-storage.com/PentHouse/meta.lcc";
        const lcc = LCCRender.load(
            {
                camera,
                scene,
                dataPath: DATA_URL,
                renderLib: THREE,
                canvas: renderer.domElement,
                renderer,
            },
            (mesh) => {
                lccObj = mesh;
                console.log("LCC object loaded:", mesh);
                setProgress(100, "Model loaded!");
                setTimeout(hideLoading, 600);
                afterLccReady();
            },
            (percent) => {
                const pct = 8 + percent * 86; // leave a little headroom
                setProgress(pct, `Loading Model: ${Math.round(percent * 100)}%`);
            }
        );

        window.obj = lcc;

        // Apply LCC settings (slight delay to ensure init)
        setTimeout(() => {
            if (!lcc) return;
            lcc.useShcoef?.(true); // lighting enhancement
            if (
                /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                    navigator.userAgent
                )
            ) {
                lcc.setMaxSplats?.(1e6);
                setProgress(95, "Optimizing for mobile…");
            } else {
                lcc.setMaxSplats?.(5e6);
            }
        }, 120);

        /* =====================================================
           UI state + helpers
        ====================================================== */
        let uiControlsOpen = false;
        let uiMeasureOpen = false;
        const baseSpeed = 0.1;
        const runSpeed = 0.25;
        const keys = Object.create(null);
        let rotating = false;

        // Reusable objects
        const vForward = new THREE.Vector3();
        const vRight = new THREE.Vector3();
        const vMove = new THREE.Vector3();
        const mouseNDC = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        // Better point picking for point clouds
        raycaster.params.Points = { threshold: 0.05 };
        const groundPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        const tmpRay = new THREE.Ray();
        const tmpVec = new THREE.Vector3();
        const pickables = [];
        function refreshPickables() {
            pickables.length = 0;
            scene.traverse((o) => {
                if (o.visible && (o.isMesh || o.isPoints)) pickables.push(o);
            });
        }

        /* =====================================================
           MOBILE: touch + virtual joystick
        ====================================================== */
        const touchState = {
            touching: false,
            twoFinger: false,
            startX: 0,
            startY: 0,
            prevX: 0,
            prevY: 0,
            pinchStart: 0,
            fovStart: camera.fov,
        };

        const joy = { x: 0, y: 0, active: false };
        function setupTouch() {
            const el = renderer.domElement;

            el.addEventListener(
                "touchstart",
                (e) => {
                    if (isMeasuring()) {
                        handleMeasureTouch(e);
                        return;
                    }
                    if (e.touches.length === 1) {
                        touchState.touching = true;
                        touchState.twoFinger = false;
                        touchState.startX = touchState.prevX = e.touches[0].clientX;
                        touchState.startY = touchState.prevY = e.touches[0].clientY;
                        rotating = true;
                        rotateIndicator.style.display = "block";
                    } else if (e.touches.length === 2) {
                        touchState.touching = true;
                        touchState.twoFinger = true;
                        touchState.pinchStart = getTouchDist(e.touches[0], e.touches[1]);
                        touchState.fovStart = camera.fov;
                    }
                    e.preventDefault();
                },
                { passive: false }
            );

            el.addEventListener(
                "touchmove",
                (e) => {
                    if (!touchState.touching) return;
                    if (e.touches.length === 1 && !touchState.twoFinger) {
                        const t = e.touches[0];
                        const dx = t.clientX - touchState.prevX;
                        const dy = t.clientY - touchState.prevY;
                        updateCameraRotation(dx * 0.5, dy * 0.5);
                        touchState.prevX = t.clientX;
                        touchState.prevY = t.clientY;
                    } else if (e.touches.length === 2) {
                        handlePinch(e);
                    }
                    e.preventDefault();
                },
                { passive: false }
            );

            el.addEventListener("touchend", () => {
                touchState.touching = touchState.twoFinger = false;
                rotating = false;
                rotateIndicator.style.display = "none";
            });
        }
        function getTouchDist(t1, t2) {
            const dx = t1.clientX - t2.clientX;
            const dy = t1.clientY - t2.clientY;
            return Math.hypot(dx, dy);
        }
        function handlePinch(e) {
            const dist = getTouchDist(e.touches[0], e.touches[1]);
            const delta = (dist - touchState.pinchStart) * 0.01;
            camera.fov = THREE.MathUtils.clamp(
                touchState.fovStart - delta * 10,
                10,
                75
            );
            camera.updateProjectionMatrix();
            touchState.pinchStart = dist;
        }
        function handleMeasureTouch(e) {
            if (e.touches.length !== 1) return;
            const t = e.touches[0];
            const p = pickPoint(t.clientX, t.clientY);
            if (p) placeMeasurePoint(p);
        }

        // Virtual joystick
        const joyEl = document.getElementById("joystick");
        const joyBase = document.getElementById("joy-base");
        const joyHandle = document.getElementById("joy-handle");
        function setupJoystick() {
            const max = 32;
            joyEl.addEventListener(
                "touchstart",
                (e) => {
                    joy.active = true;
                    updateJoy(e.touches[0]);
                    e.preventDefault();
                },
                { passive: false }
            );
            joyEl.addEventListener(
                "touchmove",
                (e) => {
                    if (!joy.active) return;
                    updateJoy(e.touches[0]);
                    e.preventDefault();
                },
                { passive: false }
            );
            joyEl.addEventListener("touchend", () => {
                joy.active = false;
                joy.x = joy.y = 0;
                joyHandle.style.transform = "translate(-50%, -50%)";
            });
            function updateJoy(t) {
                const r = joyEl.getBoundingClientRect();
                const cx = r.left + r.width / 2;
                const cy = r.top + r.height / 2;
                let dx = t.clientX - cx;
                let dy = t.clientY - cy;
                const d = Math.hypot(dx, dy);
                if (d > max) {
                    dx = (dx / d) * max;
                    dy = (dy / d) * max;
                }
                joy.x = dx / max;
                joy.y = -dy / max;
                joyHandle.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                moveIndicator.style.display =
                    joy.active && (joy.x || joy.y) ? "block" : "none";
            }
        }

        /* =====================================================
           Controls + movement
        ====================================================== */
        function updateMovement() {
            const speed = keys["shift"] ? runSpeed : baseSpeed;
            vMove.set(0, 0, 0);

            // Forward/right vectors on X‑Y plane (Z up)
            camera.getWorldDirection(vForward);
            vForward.z = 0;
            vForward.normalize();
            vRight.set(-vForward.y, vForward.x, 0);

            // Keyboard
            if (keys["w"] || keys["arrowup"]) vMove.add(vForward);
            if (keys["s"] || keys["arrowdown"]) vMove.sub(vForward);
            if (keys["d"] || keys["arrowleft"]) vMove.sub(vRight);
            if (keys["a"] || keys["arrowright"]) vMove.add(vRight);
            if (keys["q"]) vMove.z += 1;
            if (keys["e"]) vMove.z -= 1;

            // Joystick
            if (joy.active) {
                vMove.x += joy.x * speed;
                vMove.y += joy.y * speed;
            }

            if (vMove.lengthSq() > 0) {
                vMove.normalize().multiplyScalar(speed);
                camera.position.add(vMove);
                controls.target.add(vMove);
            }
        }

        // Pointer lock (desktop look)
        renderer.domElement.addEventListener("contextmenu", (e) =>
            e.preventDefault()
        );
        renderer.domElement.addEventListener("mousedown", (e) => {
            // Ignore clicks on panels/toggles
            if (
                e.target.closest(".floating-panel") ||
                e.target.closest(".circle-toggle") ||
                isMeasuring()
            )
                return;

            if (e.button === 0) {
                rotating = true;
                renderer.domElement.requestPointerLock();
                rotateIndicator.style.display = "block";
            }
        });
        renderer.domElement.addEventListener("mouseup", (e) => {
            if (e.button === 0) {
                rotating = false;
                document.exitPointerLock();
                rotateIndicator.style.display = "none";
            }
        });
        renderer.domElement.addEventListener("mousemove", (e) => {
            if (isMeasuring()) {
                updateMeasurePreview(e.clientX, e.clientY);
                return;
            }
            if (!rotating) return;
            const dx = e.movementX ?? 0;
            const dy = e.movementY ?? 0;
            if (dx || dy) updateCameraRotation(dx, dy);
        });

        // Keyboard
        window.addEventListener("keydown", (e) => {
            const key = e.key.toLowerCase();
            keys[key] = true;

            if (key === "r") {
                resetCamera();
                e.preventDefault();
            } else if (key === "m") {
                toggleMeasure();
                e.preventDefault();
            } else if (key === "escape" && isMeasuring()) {
                cancelMeasure();
                e.preventDefault();
            }

            if (
                [
                    "w",
                    "a",
                    "s",
                    "d",
                    "q",
                    "e",
                    "arrowup",
                    "arrowdown",
                    "arrowleft",
                    "arrowright",
                ].includes(key)
            ) {
                moveIndicator.textContent = keys["shift"]
                    ? "TURBO — Running…"
                    : "Moving…";
                moveIndicator.style.display = "block";
            }
        });
        window.addEventListener("keyup", (e) => {
            const key = e.key.toLowerCase();
            keys[key] = false;
            if (
                [
                    "w",
                    "a",
                    "s",
                    "d",
                    "q",
                    "e",
                    "arrowup",
                    "arrowdown",
                    "arrowleft",
                    "arrowright",
                ].includes(key)
            ) {
                moveIndicator.style.display = "none";
            }
        });

        function updateCameraRotation(dx, dy) {
            const sens = 0.002;
            camRot.yaw -= dx * sens;
            camRot.pitch -= dy * sens;
            // Clamp pitch to avoid flipping (± 89°)
            camRot.pitch = THREE.MathUtils.clamp(
                camRot.pitch,
                -Math.PI / 2 + 0.02,
                Math.PI / 2 - 0.02
            );

            const qYaw = new THREE.Quaternion().setFromAxisAngle(
                new THREE.Vector3(0, 0, 1),
                camRot.yaw
            );
            const qPitch = new THREE.Quaternion().setFromAxisAngle(
                new THREE.Vector3(1, 0, 0),
                camRot.pitch
            );
            const q = new THREE.Quaternion().multiplyQuaternions(qYaw, qPitch);
            camera.setRotationFromQuaternion(q);
            updateControlsTarget();
        }
        function resetCamera() {
            camera.position.set(9, 2, 2);
            camRot.yaw = 0;
            camRot.pitch = 0;
            camera.setRotationFromEuler(new THREE.Euler(0, 0, 0));
            updateControlsTarget();
        }
        function updateControlsTarget() {
            camera.getWorldDirection(vForward);
            controls.target.copy(camera.position).add(vForward.multiplyScalar(10));
        }

        /* =====================================================
           Panels + toggles
        ====================================================== */
        function togglePanel(button, panel, open) {
            const state = open ?? !panel.classList.contains("visible");
            panel.classList.toggle("visible", state);
            panel.setAttribute("aria-hidden", String(!state));
            button.setAttribute("aria-pressed", String(state));
            return state;
        }
        controlsToggle.addEventListener("click", (e) => {
            e.stopPropagation();
            uiControlsOpen = togglePanel(
                controlsToggle,
                controlsPanel,
                !uiControlsOpen
            );
            controlsToggle.textContent = uiControlsOpen ? "✕" : "⚙️";
        });
        measureToggle.addEventListener("click", (e) => {
            e.stopPropagation();
            uiMeasureOpen = togglePanel(
                measureToggle,
                measurePanel,
                !uiMeasureOpen
            );
            measureToggle.textContent = uiMeasureOpen ? "✕" : "📐";
        });

        // Prevent pointer lock when clicking inside panels
        document.querySelectorAll(".floating-panel").forEach((el) => {
            el.addEventListener("mousedown", (e) => e.stopPropagation());
            el.addEventListener("wheel", (e) => e.stopPropagation(), {
                passive: true,
            });
        });

        /* =====================================================
           Measurement system
        ====================================================== */
        const M_TO_FT = 3.28084;
        const measure = {
            active: false,
            mode: "two", // "two" | "path"
            unit: "m", // "m" | "ft"
            pickMode: "surface", // "surface" | "ground"
            pts: [], // Vector3[]
            spheres: [],
            labels: [],
            line: null, // THREE.Line (final)
            preview: null, // THREE.Line (rubber band)
            total: 0,
        };

        function isMeasuring() {
            return measure.active;
        }

        function toggleMeasure() {
            if (measure.active) cancelMeasure();
            else startMeasure();
        }

        function startMeasure() {
            measure.active = true;
            measure.pts.length = 0;
            clearMeasureVisuals();
            updateMeasureUI();
            notes.textContent = "Place the first point…";
            btnFinish.disabled = measure.mode === "two";
            btnClear.disabled = true;
            renderer.domElement.style.cursor = "crosshair";
        }

        function finishMeasure() {
            if (!measure.active) return;
            if (measure.mode === "two" && measure.pts.length < 2) return;
            if (measure.mode === "path" && measure.pts.length < 2) return;
            finalizeMeasure();
        }

        function cancelMeasure() {
            measure.active = false;
            clearMeasureVisuals();
            updateMeasureUI();
            output.textContent = "0.00 " + (measure.unit === "m" ? "m" : "ft");
            notes.textContent = "Cancelled.";
            renderer.domElement.style.cursor = "";
        }

        function clearMeasure() {
            clearMeasureVisuals();
            measure.pts.length = 0;
            measure.total = 0;
            output.textContent = "0.00 " + (measure.unit === "m" ? "m" : "ft");
            notes.textContent = "Cleared. Start a new measure.";
            segmentsList.style.display = "none";
            btnClear.disabled = true;
            btnCopy.disabled = true;
        }

        function clearMeasureVisuals() {
            if (measure.line) {
                scene.remove(measure.line);
                measure.line.geometry.dispose();
                measure.line = null;
            }
            if (measure.preview) {
                scene.remove(measure.preview);
                measure.preview.geometry.dispose();
                measure.preview = null;
            }
            for (const s of measure.spheres) scene.remove(s);
            for (const l of measure.labels) scene.remove(l);
            measure.spheres.length = 0;
            measure.labels.length = 0;
            segmentsList.innerHTML = "";
        }

        function finishAndFreeze() {
            measure.active = false;
            renderer.domElement.style.cursor = "";
            btnFinish.disabled = true;
            btnCopy.disabled = false;
            btnClear.disabled = false;
            updateMeasureUI();
        }

        function placeMeasurePoint(p) {
            if (!measure.active) return;
            measure.pts.push(p.clone());
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.05, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xff5a6a })
            );
            sphere.position.copy(p);
            scene.add(sphere);
            measure.spheres.push(sphere);

            if (measure.mode === "two") {
                if (measure.pts.length === 1) {
                    notes.textContent = "First point set. Place the second point…";
                    btnClear.disabled = false;
                    buildPreview(measure.pts[0], p);
                } else if (measure.pts.length === 2) {
                    finalizeMeasure();
                }
            } else {
                // path mode
                btnFinish.disabled = false;
                btnClear.disabled = false;
                if (measure.pts.length >= 2) {
                    buildFinalLine(measure.pts);
                    updateMeasureNumbers();
                }
                notes.textContent = "Add more points or press Finish.";
            }
        }

        function finalizeMeasure() {
            if (measure.preview) {
                scene.remove(measure.preview);
                measure.preview.geometry.dispose();
                measure.preview = null;
            }
            if (measure.mode === "two" && measure.pts.length === 2) {
                buildFinalLine(measure.pts);
                updateMeasureNumbers();
            } else if (measure.mode === "path" && measure.pts.length >= 2) {
                buildFinalLine(measure.pts);
                updateMeasureNumbers();
            }
            finishAndFreeze();
        }

        // Build preview "rubber band"
        function buildPreview(a, current) {
            if (measure.preview) {
                measure.preview.geometry.dispose();
                scene.remove(measure.preview);
                measure.preview = null;
            }
            const geo = new THREE.BufferGeometry().setFromPoints([a, current]);
            const mat = new THREE.LineDashedMaterial({
                color: 0x4fa1ff,
                dashSize: 0.15,
                gapSize: 0.08,
            });
            const line = new THREE.LineSegments(geo, mat);
            line.computeLineDistances();
            scene.add(line);
            measure.preview = line;
        }

        function buildFinalLine(points) {
            if (measure.line) {
                measure.line.geometry.dispose();
                scene.remove(measure.line);
                measure.line = null;
            }
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            const mat = new THREE.LineBasicMaterial({
                color: 0x4fa1ff,
                linewidth: 2,
            });
            const line = new THREE.Line(geo, mat);
            scene.add(line);
            measure.line = line;

            // Labels (segment midpoints)
            for (let i = 0; i < points.length - 1; i++) {
                const mid = points[i].clone().lerp(points[i + 1], 0.5);
                const dist = points[i].distanceTo(points[i + 1]);
                const label = makeLabelSprite(formatDistance(dist));
                label.position.copy(mid).add(new THREE.Vector3(0, 0, 0.05));
                scene.add(label);
                measure.labels.push(label);
            }
        }

        // Screen pick (surface first; fallback to ground z=0)
        function pickPoint(clientX, clientY) {
            mouseNDC.x = (clientX / window.innerWidth) * 2 - 1;
            mouseNDC.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouseNDC, camera);

            // Surface picking
            if (measure.pickMode === "surface" && pickables.length) {
                const hits = raycaster.intersectObjects(pickables, true);
                if (hits.length) return hits[0].point.clone();
            }

            // Ground fallback
            tmpRay.origin.copy(camera.position);
            tmpRay.direction.copy(raycaster.ray.direction);
            const hit = tmpRay.intersectPlane(groundPlane, new THREE.Vector3());
            return hit ? hit.clone() : null;
        }

        function updateMeasurePreview(clientX, clientY) {
            if (!measure.active) return;
            if (measure.mode === "two" && measure.pts.length === 1) {
                const p = pickPoint(clientX, clientY);
                if (!p) return;
                buildPreview(measure.pts[0], p);
                // live output
                const d = measure.pts[0].distanceTo(p);
                output.textContent = formatDistance(d);
                notes.textContent = "Click to place the second point.";
            } else if (measure.mode === "path" && measure.pts.length >= 1) {
                const p = pickPoint(clientX, clientY);
                if (!p) return;
                const last = measure.pts[measure.pts.length - 1];
                buildPreview(last, p);
                const d = last.distanceTo(p);
                output.textContent =
                    formatDistance(measure.total + d) + " (incl. current segment)";
            }
        }

        function updateMeasureNumbers() {
            if (measure.pts.length < 2) return;
            let total = 0;
            let html = "";
            for (let i = 0; i < measure.pts.length - 1; i++) {
                const d = measure.pts[i].distanceTo(measure.pts[i + 1]);
                total += d;
                html += `Segment ${i + 1}: <strong>${formatDistance(
                    d
                )}</strong><br/>`;
            }
            measure.total = total;
            output.textContent = formatDistance(total);
            segmentsList.innerHTML = html;
            segmentsList.style.display = measure.mode === "path" ? "block" : "none";
            notes.textContent = "Measurement complete.";
        }

        function formatDistance(meters) {
            if (measure.unit === "m") return meters.toFixed(2) + " m";
            return (meters * M_TO_FT).toFixed(2) + " ft";
        }

        // Simple text label as sprite
        function makeLabelSprite(text) {
            const padding = 6;
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            const font = "bold 22px system-ui, -apple-system, Segoe UI, Roboto";
            ctx.font = font;
            const metrics = ctx.measureText(text);
            const w = Math.ceil(metrics.width + padding * 2);
            const h = 34;
            canvas.width = w;
            canvas.height = h;
            ctx.font = font;
            // bg
            ctx.fillStyle = "rgba(0,0,0,0.75)";
            roundRect(ctx, 0, 0, w, h, 12);
            ctx.fill();
            // text
            ctx.fillStyle = "#ffffff";
            ctx.textBaseline = "middle";
            ctx.fillText(text, padding, h / 2);
            const tex = new THREE.CanvasTexture(canvas);
            tex.minFilter = THREE.LinearFilter;
            const mat = new THREE.SpriteMaterial({
                map: tex,
                depthTest: false,
                depthWrite: false,
            });
            const spr = new THREE.Sprite(mat);
            const scale = 0.35; // world units
            spr.scale.set((w / h) * scale, scale, 1);
            return spr;
        }
        function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        // Mouse/touch input for measuring
        renderer.domElement.addEventListener("mousedown", (e) => {
            if (!measure.active) return;
            if (e.button !== 0) return;
            const p = pickPoint(e.clientX, e.clientY);
            if (p) placeMeasurePoint(p);
            e.preventDefault();
        });

        // UI controls
        btnStart.addEventListener("click", startMeasure);
        btnFinish.addEventListener("click", finishMeasure);
        btnClear.addEventListener("click", clearMeasure);
        btnCopy.addEventListener("click", async () => {
            try {
                await navigator.clipboard.writeText(output.textContent);
                notes.textContent = "Copied to clipboard.";
            } catch {
                notes.textContent = "Copy failed (permissions).";
            }
        });

        // Pick mode
        pickSurfaceBtn.addEventListener("click", () => {
            measure.pickMode = "surface";
            pickSurfaceBtn.classList.add("on");
            pickGroundBtn.classList.remove("on");
        });
        pickGroundBtn.addEventListener("click", () => {
            measure.pickMode = "ground";
            pickGroundBtn.classList.add("on");
            pickSurfaceBtn.classList.remove("on");
        });

        // Units
        unitButtons.forEach((b) => {
            b.addEventListener("click", () => {
                unitButtons.forEach((x) => x.classList.remove("on"));
                b.classList.add("on");
                measure.unit = b.dataset.unit;
                if (measure.total) output.textContent = formatDistance(measure.total);
                updateMeasureNumbers();
            });
        });

        // Mode
        modeButtons.forEach((b) => {
            b.addEventListener("click", () => {
                modeButtons.forEach((x) => x.classList.remove("on"));
                b.classList.add("on");
                measure.mode = b.dataset.mode;
                notes.textContent =
                    measure.mode === "two"
                        ? "Two‑point mode. Place two points."
                        : "Path mode. Place multiple points then Finish.";
                // UI affordance
                btnFinish.disabled = measure.mode === "two";
            });
        });

        function updateMeasureUI() {
            btnStart.disabled = measure.active;
            btnFinish.disabled = measure.mode === "two" ? true : !measure.active;
            btnClear.disabled = !measure.active && measure.pts.length === 0;
            btnCopy.disabled = !measure.line;
            measureToggle.setAttribute("aria-pressed", String(uiMeasureOpen));
        }

        /* =====================================================
           App lifecycle
        ====================================================== */
        function afterLccReady() {
            refreshPickables();
            setupTouch();
            setupJoystick();
            enableUI();
        }

        function enableUI() {
            // Nothing extra right now (kept for parity with original)
        }

        // Animation
        renderer.setAnimationLoop(() => {
            updateMovement();
            controls.update();
            LCCRender.update();
            renderer.render(scene, camera);
        });

        // Resize
        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(DPR());
        });

        // Prevent native browser gestures
        document.addEventListener(
            "touchmove",
            (e) => {
                if (e.touches.length > 1) e.preventDefault();
            },
            { passive: false }
        );

        /* =====================================================
           Utilities
        ====================================================== */
        function updateJoy() { } // placeholder (already defined in setupJoystick scope)

        function enableUIPointerGuards() { } // kept for potential extensions
    </script>
</body>

</html>