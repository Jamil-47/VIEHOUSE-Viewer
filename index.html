<implementation_plan>
    <!-- EMERGEEEEEEEEEEEEEEEEEEENT -->
    <!-- - Clean and organize structure: consolidate CSS with variables, group UI sections, and cache DOM/Three.js objects.
- Remove redundancies: unused variables/comments, duplicate logic, and per-frame allocations.
- Optimize interactions: reuse vectors/raycaster, correct key mappings, minimal DOM updates, safe disposals.
- Maintain functionality: same UI/UX behavior, measurement flow, movement/rotation, and dataPath/logo paths. -->
</implementation_plan>

<!-- Cleaned & enhanced code -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VIEHOUSE - 3D Property Viewer</title>
    <style>
        :root {
            --bg: #1a1a1a;
            --panel-bg: rgba(0, 0, 0, 0.85);
            --panel-border: rgba(255, 255, 255, 0.2);
            --white-90: rgba(255, 255, 255, 0.9);
            --white-70: rgba(255, 255, 255, 0.7);
            --white-50: rgba(255, 255, 255, 0.5);
            --shadow-strong: 0 8px 32px rgba(0, 0, 0, 0.4);
            --shadow-medium: 0 4px 15px rgba(0, 0, 0, 0.4);
            --shadow-soft: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg);
            color: #fff;
        }

        /* Panels (hidden by default; toggle via .visible) */
        #ui-container,
        #measurement-panel {
            position: absolute;
            background: var(--panel-bg);
            padding: 15px;
            border-radius: 15px;
            font-size: 13px;
            z-index: 100;
            border: 1px solid var(--panel-border);
            box-shadow: var(--shadow-strong);
            backdrop-filter: blur(10px);
            transition: transform 0.3s ease, opacity 0.3s ease;
            opacity: 0;
        }

        #ui-container {
            top: 20px;
            left: 20px;
            max-width: 280px;
            pointer-events: none;
            transform: translateX(-100%);
        }

        #ui-container.visible {
            transform: translateX(0);
            opacity: 1;
        }

        #measurement-panel {
            top: 20px;
            right: 20px;
            min-width: 220px;
            pointer-events: auto;
            transform: translateX(100%);
        }

        #measurement-panel.visible {
            transform: translateX(0);
            opacity: 1;
        }

        /* Round toggle buttons */
        .ui-toggle,
        .measurement-toggle {
            position: absolute;
            top: 20px;
            width: 40px;
            height: 40px;
            background: var(--white-90);
            border: none;
            border-radius: 50%;
            color: #000;
            font-size: 18px;
            cursor: pointer;
            z-index: 101;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-medium);
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .ui-toggle {
            left: 20px;
        }

        .measurement-toggle {
            right: 20px;
        }

        .ui-toggle:hover,
        .measurement-toggle:hover {
            transform: scale(1.1);
            background: #fff;
        }

        .ui-section {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--panel-border);
        }

        .ui-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .section-title {
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            padding: 4px 0;
        }

        .control-key {
            background: var(--white-90);
            color: #000;
            padding: 4px 8px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 11px;
            min-width: 70px;
            text-align: center;
            box-shadow: var(--shadow-soft);
        }

        .control-label {
            font-size: 12px;
            color: var(--white-90);
            text-align: right;
            flex: 1;
            margin-left: 8px;
        }

        /* Visual control cards */
        .control-cards {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }

        .control-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-icon {
            width: 30px;
            height: 30px;
            background: var(--white-90);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .control-card .control-key {
            background: transparent;
            color: #fff;
            padding: 2px 4px;
            font-size: 9px;
            box-shadow: none;
            min-width: auto;
        }

        .control-description {
            font-size: 9px;
            color: var(--white-70);
            text-align: center;
        }

        /* Indicators */
        #movement-indicator,
        #rotation-indicator {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            display: none;
            box-shadow: var(--shadow-medium);
            z-index: 101;
            border: 1px solid var(--panel-border);
        }

        #movement-indicator {
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
        }

        #rotation-indicator {
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
        }

        /* Logo */
        #vihouse-logo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            z-index: 99;
            pointer-events: none;
        }

        .logo-container {
            width: 80px;
            height: 80px;
            background: #fff;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.8);
            padding: 12px;
            overflow: hidden;
        }

        .logo-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
            max-width: 100%;
            max-height: 100%;
        }

        .powered-by {
            font-size: 10px;
            color: var(--white-90);
            font-weight: 500;
            margin-top: 2px;
            text-align: center;
        }
    </style>
</head>

<body>
    <button class="ui-toggle" id="ui-toggle" aria-label="Toggle controls" data-testid="toggle-controls">
        ‚öôÔ∏è
    </button>
    <button class="measurement-toggle" id="measurement-toggle" aria-label="Toggle measurement panel"
        data-testid="toggle-measurement">
        üìê
    </button>

    <div id="ui-container" aria-hidden="true" data-testid="controls-panel">
        <div class="ui-section">
            <div class="section-title">üéÆ NAVIGATION CONTROLS</div>
            <div class="control-item">
                <div class="control-key">LEFT CLICK</div>
                <div class="control-label">360¬∞ Camera Rotation</div>
            </div>
            <div class="control-item">
                <div class="control-key">RIGHT CLICK</div>
                <div class="control-label">Pan / Move Camera</div>
            </div>
            <div class="control-item">
                <div class="control-key">MOUSE WHEEL</div>
                <div class="control-label">Zoom In/Out</div>
            </div>
            <div class="control-item">
                <div class="control-key">MIDDLE CLICK</div>
                <div class="control-label">Quick Zoom</div>
            </div>
        </div>

        <div class="ui-section">
            <div class="section-title"> MOVEMENT</div>
            <div class="control-item">
                <div class="control-key">W / ‚Üë</div>
                <div class="control-label">Move Forward</div>
            </div>
            <div class="control-item">
                <div class="control-key">S / ‚Üì</div>
                <div class="control-label">Move Backward</div>
            </div>
            <div class="control-item">
                <div class="control-key">A / ‚Üê</div>
                <div class="control-label">Move Left</div>
            </div>
            <div class="control-item">
                <div class="control-key">D / ‚Üí</div>
                <div class="control-label">Move Right</div>
            </div>
            <div class="control-item">
                <div class="control-key">Q</div>
                <div class="control-label">Move Up</div>
            </div>
            <div class="control-item">
                <div class="control-key">E</div>
                <div class="control-label">Move Down</div>
            </div>
            <div class="control-item">
                <div class="control-key">SHIFT</div>
                <div class="control-label">Turbo Speed</div>
            </div>
        </div>

        <div class="ui-section">
            <div class="section-title"> QUICK CONTROLS</div>
            <div class="control-cards">
                <div class="control-card">
                    <div class="control-icon">üëÅÔ∏è</div>
                    <div class="control-key">LOOK</div>
                    <div class="control-description">Left Click</div>
                </div>
                <div class="control-card">
                    <div class="control-icon">üîÑ</div>
                    <div class="control-key">PAN</div>
                    <div class="control-description">Right Click</div>
                </div>
                <div class="control-card">
                    <div class="control-icon">üèÉ</div>
                    <div class="control-key">MOVE</div>
                    <div class="control-description">WASD</div>
                </div>
                <div class="control-card">
                    <div class="control-icon">‚ö°</div>
                    <div class="control-key">TURBO</div>
                    <div class="control-description">Shift</div>
                </div>
            </div>
        </div>
    </div>

    <div id="measurement-panel" aria-hidden="true" data-testid="measurement-panel">
        <div class="section-title">üìê MEASUREMENT TOOL</div>
        <div class="measurement-controls">
            <button class="measure-btn" id="start-measure" data-testid="start-measure">
                Start Measure
            </button>
            <button class="measure-btn" id="clear-measure" data-testid="clear-measure" disabled>
                Clear
            </button>
        </div>
        <div class="measurement-info">
            <div style="font-size: 11px; color: var(--white-70); margin-bottom: 6px">
                Click two points in the 3D space to measure distance
            </div>
            <div class="measurement-result" id="distance-result" data-testid="distance-result">
                0.00 m
            </div>
            <div class="measurement-points" id="points-info" data-testid="points-info">
                Click first point...
            </div>
        </div>
    </div>

    <div id="vihouse-logo" data-testid="vihouse-logo">
        <div class="logo-container">
            <img src="images/VIEHOUSE_logo.png" alt="VIEHOUSE Logo" />
        </div>
        <div class="powered-by">POWERED BY<br />VIEHOUSE</div>
    </div>

    <div id="movement-indicator" data-testid="movement-indicator">
        Moving...
    </div>
    <div id="rotation-indicator" data-testid="rotation-indicator">
        Rotating Camera...
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "./lib/three/three.module.js",
          "three/addons/": "./lib/three/jsm/"
        }
      }
    </script>

    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { LCCRender } from "./sdk/lcc-0.4.0.js";

        // Scene & renderer
        const scene = new THREE.Scene();
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x1a1a1a);
        document.body.appendChild(renderer.domElement);

        // Camera
        const camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.up.set(0, 0, 1);
        camera.position.set(9, 2, 2);
        // Manual rotation state
        const cameraRotation = { yaw: 0, pitch: 0 };

        // OrbitControls for pan/zoom; rotation is manual
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableRotate = false;
        controls.enableZoom = true;
        controls.enablePan = true;
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.panSpeed = 1.5;
        controls.zoomSpeed = 1.2;
        controls.mouseButtons = {
            LEFT: null,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.PAN,
        };
        controls.update();


        // ‚úÖ use your Blob folder (PUBLIC, ends with '/')
        const DATA_URL = "https://7cljve8li97skpij.public.blob.vercel-storage.com/PentHouse/meta.lcc";

        const lccObj = LCCRender.load(
            {
                camera,
                scene,
                dataPath: DATA_URL,           // <-- file, not folder
                renderLib: THREE,
                canvas: renderer.domElement,
                renderer,
            },
            (mesh) => console.log("LCC object Loaded:", mesh),
            (percent) => console.log("LCC loading:", (percent * 100).toFixed(1) + "%")
        );


        // // Load LCC object (kept as-is)
        // const lccObj = LCCRender.load(
        //     {
        //         camera,
        //         scene,
        //         dataPath: "http://localhost:5501/data/PentHouse/meta.lcc",
        //         renderLib: THREE,
        //         canvas: renderer.domElement,
        //         renderer,
        //     },
        //     (mesh) => console.log("LCC object Loaded:", mesh),
        //     (percent) => console.log("LCC loading:", percent * 100 + "%")
        // );



        window.obj = lccObj;
        // IMPOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOORTANT
        lccObj.useShcoef(true); //enhances the shadow and light
        // lccObj.getCurrentConfig()
        // lccObj.setMaxDistance(50) // in meters for sure
        lccObj.setMaxSplats(3e6); // ÿ¥ŸàŸÅ ÿßŸÑŸÖÿ™ÿπÿ© ÿ®ÿ≥ ÿ®ÿØŸáÿß ÿ¨Ÿáÿßÿ≤

        // UI cache
        const uiToggle = document.getElementById("ui-toggle");
        const uiContainer = document.getElementById("ui-container");
        const measurementToggle = document.getElementById("measurement-toggle");
        const measurementPanel = document.getElementById("measurement-panel");
        const movementIndicator = document.getElementById("movement-indicator");
        const rotationIndicator = document.getElementById("rotation-indicator");
        const startMeasureBtn = document.getElementById("start-measure");
        const clearMeasureBtn = document.getElementById("clear-measure");
        const distanceResultEl = document.getElementById("distance-result");
        const pointsInfoEl = document.getElementById("points-info");

        // State
        let uiVisible = false;
        let measurementVisible = false;
        const baseSpeed = 0.1;
        const runSpeed = 0.25;
        const keysPressed = {};
        let isRotating = false;

        // Reusable objects to reduce allocations
        const vForward = new THREE.Vector3();
        const vRight = new THREE.Vector3();
        const vMove = new THREE.Vector3();
        const mouseNDC = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        const groundPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        const intersectionPoint = new THREE.Vector3();
        const tmpRay = new THREE.Ray();

        // Measurement
        let isMeasuring = false;
        let measurementPoints = [];
        let measurementLine = null;
        let measurementSpheres = [];
        const measurementMaterial = new THREE.LineBasicMaterial({
            color: 0xff0000,
            linewidth: 2,
        });
        const sphereGeometry = new THREE.SphereGeometry(0.05, 16, 16);
        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });

        // UI toggles
        uiToggle.addEventListener("click", () => {
            uiVisible = !uiVisible;
            uiContainer.classList.toggle("visible", uiVisible);
            uiContainer.setAttribute("aria-hidden", String(!uiVisible));
            uiToggle.textContent = uiVisible ? "‚úï" : "‚öôÔ∏è";
        });

        measurementToggle.addEventListener("click", () => {
            measurementVisible = !measurementVisible;
            measurementPanel.classList.toggle("visible", measurementVisible);
            measurementPanel.setAttribute(
                "aria-hidden",
                String(!measurementVisible)
            );
            measurementToggle.textContent = measurementVisible ? "‚úï" : "üìê";
        });

        // Measurement controls
        function startMeasurement() {
            isMeasuring = true;
            measurementPoints = [];
            clearMeasurementVisuals();
            startMeasureBtn.textContent = "Click First Point";
            pointsInfoEl.textContent = "Click first point in 3D space...";
            clearMeasureBtn.disabled = false;
        }

        function clearMeasurement() {
            isMeasuring = false;
            measurementPoints = [];
            clearMeasurementVisuals();
            startMeasureBtn.textContent = "Start Measure";
            pointsInfoEl.textContent = "Click first point...";
            distanceResultEl.textContent = "0.00 m";
            clearMeasureBtn.disabled = true;
        }

        function clearMeasurementVisuals() {
            if (measurementLine) {
                scene.remove(measurementLine);
                measurementLine.geometry.dispose();
                measurementLine = null;
            }
            for (const sphere of measurementSpheres) {
                scene.remove(sphere);
            }
            measurementSpheres = [];
        }

        function addMeasurementPoint(point) {
            measurementPoints.push(point.clone());

            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.copy(point);
            scene.add(sphere);
            measurementSpheres.push(sphere);

            if (measurementPoints.length === 1) {
                startMeasureBtn.textContent = "Click Second Point";
                pointsInfoEl.textContent = "First point set. Click second point...";
            } else if (measurementPoints.length === 2) {
                calculateDistance();
                startMeasureBtn.textContent = "New Measure";
                pointsInfoEl.textContent =
                    'Measurement complete. Click "New Measure" to start over.';
            }
        }

        function calculateDistance() {
            if (measurementPoints.length !== 2) return;
            const distance = measurementPoints[0].distanceTo(measurementPoints[1]);
            distanceResultEl.textContent = `${distance.toFixed(2)} m`;

            const lineGeometry = new THREE.BufferGeometry().setFromPoints(
                measurementPoints
            );
            measurementLine = new THREE.Line(lineGeometry, measurementMaterial);
            scene.add(measurementLine);
        }

        startMeasureBtn.addEventListener("click", startMeasurement);
        clearMeasureBtn.addEventListener("click", clearMeasurement);

        // Mouse interaction
        renderer.domElement.addEventListener("contextmenu", (e) =>
            e.preventDefault()
        );

        renderer.domElement.addEventListener("mousedown", (event) => {
            if (event.button !== 0) return;

            if (isMeasuring) {
                mouseNDC.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouseNDC.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouseNDC, camera);
                tmpRay.origin.copy(camera.position);
                tmpRay.direction.copy(raycaster.ray.direction);

                if (tmpRay.intersectPlane(groundPlane, intersectionPoint)) {
                    addMeasurementPoint(intersectionPoint);
                }
            } else {
                isRotating = true;
                renderer.domElement.requestPointerLock();
                rotationIndicator.style.display = "block";
            }
            event.preventDefault();
        });

        renderer.domElement.addEventListener("mouseup", (event) => {
            if (event.button !== 0) return;
            isRotating = false;
            document.exitPointerLock();
            rotationIndicator.style.display = "none";
        });

        renderer.domElement.addEventListener("mousemove", (event) => {
            if (!isRotating || isMeasuring) return;
            const dx = event.movementX ?? 0;
            const dy = event.movementY ?? 0;
            if (dx !== 0 || dy !== 0) updateCameraRotation(dx, dy);
        });

        // Keyboard
        window.addEventListener("keydown", (e) => {
            const key = e.key.toLowerCase();
            keysPressed[key] = true;

            if (key === "r") {
                resetCamera();
                e.preventDefault();
            } else if (key === "m") {
                isMeasuring ? clearMeasurement() : startMeasurement();
                e.preventDefault();
            }

            if (
                [
                    "w",
                    "a",
                    "s",
                    "d",
                    "q",
                    "e",
                    "arrowup",
                    "arrowdown",
                    "arrowleft",
                    "arrowright",
                ].includes(key)
            ) {
                movementIndicator.style.display = "block";
                movementIndicator.textContent = keysPressed["shift"]
                    ? "TURBO MODE - Running..."
                    : "Moving...";
            }
        });

        window.addEventListener("keyup", (e) => {
            const key = e.key.toLowerCase();
            keysPressed[key] = false;

            if (
                [
                    "w",
                    "a",
                    "s",
                    "d",
                    "q",
                    "e",
                    "arrowup",
                    "arrowdown",
                    "arrowleft",
                    "arrowright",
                ].includes(key)
            ) {
                movementIndicator.style.display = "none";
            }
        });

        // Rotation helpers
        function updateCameraRotation(deltaX, deltaY) {
            const sensitivity = 0.002;
            cameraRotation.yaw -= deltaX * sensitivity;
            cameraRotation.pitch -= deltaY * sensitivity;

            const qYaw = new THREE.Quaternion().setFromAxisAngle(
                new THREE.Vector3(0, 0, 1),
                cameraRotation.yaw
            );
            const qPitch = new THREE.Quaternion().setFromAxisAngle(
                new THREE.Vector3(1, 0, 0),
                cameraRotation.pitch
            );
            const q = new THREE.Quaternion().multiplyQuaternions(qYaw, qPitch);

            camera.setRotationFromQuaternion(q);
            updateControlsTarget();
        }

        function resetCamera() {
            // IMPPPPPPPPPPORTANT to set the intial point.
            camera.position.set(9, 2, 2);
            cameraRotation.yaw = 0;
            cameraRotation.pitch = 0;
            camera.setRotationFromEuler(new THREE.Euler(0, 0, 0));
            updateControlsTarget();
        }

        function updateControlsTarget() {
            camera.getWorldDirection(vForward);
            controls.target.copy(camera.position).add(vForward.multiplyScalar(10));
        }

        // Movement update (WASD + arrows + QE)
        function updateMovement() {
            const speed = keysPressed["shift"] ? runSpeed : baseSpeed;

            camera.getWorldDirection(vForward);
            vForward.z = 0;
            vForward.normalize();

            vRight.set(-vForward.y, vForward.x, 0);
            vMove.set(0, 0, 0);

            if (keysPressed["w"] || keysPressed["arrowup"]) vMove.add(vForward);
            if (keysPressed["s"] || keysPressed["arrowdown"]) vMove.sub(vForward);
            if (keysPressed["a"] || keysPressed["arrowright"]) vMove.add(vRight);
            if (keysPressed["d"] || keysPressed["arrowleft"]) vMove.sub(vRight);
            if (keysPressed["q"]) vMove.z += 1;
            if (keysPressed["e"]) vMove.z -= 1;

            if (vMove.lengthSq() > 0) {
                vMove.normalize().multiplyScalar(speed);
                camera.position.add(vMove);
                controls.target.add(vMove);
            }
        }

        // Main loop
        function animate() {
            renderer.setAnimationLoop(() => {
                updateMovement();
                controls.update();
                LCCRender.update();
                renderer.render(scene, camera);
            });
        }

        // Resize
        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>

</html>